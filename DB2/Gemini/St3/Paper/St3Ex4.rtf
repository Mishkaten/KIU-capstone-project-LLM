{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 HelveticaNeue-Bold;\f2\fnil\fcharset0 HelveticaNeue-Italic;
}
{\colortbl;\red255\green255\blue255;\red220\green220\blue220;\red16\green16\blue16;}
{\*\expandedcolortbl;;\cssrgb\c89020\c89020\c89020;\cssrgb\c7451\c7451\c7843;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid1\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa240\partightenfactor0

\f0\fs32 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In this scenario with PostgreSQL's Serializable Snapshot Isolation (SSI), we can expect the following behavior and hypothesis:\
\pard\pardeftab720\sa240\partightenfactor0

\f1\b \cf2 How PostgreSQL SSI Behaves:
\f0\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls1\ilvl0
\f1\b \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Snapshot Isolation:
\f0\b0   Both Alice and Bob begin their transactions by reading a snapshot of the duty list. This snapshot reflects the state of the database at the beginning of their respective transactions.\cb1 \
\ls1\ilvl0
\f1\b \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Write Intent:
\f0\b0   When Alice and Bob attempt to update the duty list (remove themselves), PostgreSQL tracks their 
\f2\i write intent
\f0\i0  on the relevant rows.\cb1 \
\ls1\ilvl0
\f1\b \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Conflict Detection:
\f0\b0  SSI detects a potential write skew because both Alice and Bob intend to modify the same data (the duty list) in a way that could violate the constraint of having at least two people on duty.\cb1 \
\ls1\ilvl0
\f1\b \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	4	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Serialization Error:
\f0\b0   To maintain serializability, PostgreSQL will abort one of the transactions (either Alice's or Bob's), raising a serialization error. The aborted transaction will have to be retried.\cb1 \
\pard\pardeftab720\sa240\partightenfactor0

\f1\b \cf2 \cb3 Hypothesis:
\f0\b0 \
The specific transaction to be aborted is not deterministic. PostgreSQL will likely choose one at random or based on some internal heuristics.  The goal is to ensure that only one of the conflicting transactions succeeds, guaranteeing that at least two people remain on the duty list.\

\f1\b Additional Considerations:
\f0\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls2\ilvl0
\f1\b \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Predictable Locks:
\f0\b0  While SSI primarily relies on snapshot isolation and optimistic concurrency control, it may also use predictable locks in certain situations to prevent write skews. These locks would be acquired on the duty list to ensure exclusive access during the update process.\cb1 \
\ls2\ilvl0
\f1\b \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Transaction Fallback:
\f0\b0  The aborted transaction (either Alice's or Bob's) can be automatically retried by the application. Upon retry, it will read a fresh snapshot of the database, which may have already been modified by the successful transaction. This ensures that the retrying transaction sees the updated state and makes a decision based on the most current information.\cb1 \
}