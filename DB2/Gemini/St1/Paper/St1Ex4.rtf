{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\froman\fcharset0 Times-Bold;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid1\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa240\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Postgres SSI will detect a potential write skew and abort one of the transactions (either Alice's or Bob's).\
\pard\pardeftab720\sa240\partightenfactor0

\f1\b \cf0 Explanation:
\f0\b0 \
Here's how Postgres SSI would likely handle this scenario:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls1\ilvl0
\f1\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Snapshot Isolation:
\f0\b0  Both Alice and Bob begin their transactions and read the current state of the duty list (4 people on duty).\
\ls1\ilvl0
\f1\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Write Intent:
\f0\b0  Both Alice and Bob intend to remove themselves from the duty list, which would result in only two people remaining on duty (Joe and Susan).\
\ls1\ilvl0
\f1\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Conflict Detection:
\f0\b0  When either Alice or Bob tries to commit their transaction, Postgres SSI detects a potential write skew. This is because the transactions are based on the same initial snapshot, and both are trying to modify the data in a way that violates the constraint (minimum of 2 people on duty).\
\ls1\ilvl0
\f1\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	4	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Serialization Error:
\f0\b0  Postgres SSI will raise a serialization error to abort one of the transactions. The choice of which transaction to abort can be arbitrary or based on some internal heuristics.\
\ls1\ilvl0
\f1\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	5	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Retry:
\f0\b0  The aborted transaction can be retried. In the retry, it will read the latest state of the duty list (which might have been modified by the other transaction).\
\pard\pardeftab720\sa240\partightenfactor0

\f1\b \cf0 Why this is important:
\f0\b0 \
Write skew anomalies can occur when two transactions read the same data, then update different parts of it based on that initial read. This can lead to inconsistencies and violate application constraints. SSI helps prevent these anomalies by detecting conflicts between concurrent transactions and ensuring that the resulting database state is equivalent to some serial execution of the transactions.\
}